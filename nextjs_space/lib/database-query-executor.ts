
/**
 * Database Query Executor
 * Executes SQL queries against actual database tables using Prisma
 * 
 * PERFORMANCE OPTIMIZATIONS:
 * - Multi-tier query caching (hot/warm/cold)
 * - Intelligent cache tier selection
 * - Query result deduplication
 */

import { prisma } from './db'
import { cachedQuery } from './db-optimization'

/**
 * Helper function to wrap query results with explanation
 */
function wrapResult(data: any[], explanation: string): { data: any[], explanation: string } {
  return { data, explanation }
}

/**
 * Validates SQL query to prevent injection attacks
 * Only allows SELECT statements and blocks dangerous operations
 */
function validateSQL(sql: string): { valid: boolean; error?: string } {
  if (!sql || sql.trim().length === 0) {
    return { valid: false, error: 'Empty SQL query' };
  }

  // Remove comments and normalize whitespace
  const normalized = sql
    .replace(/--.*$/gm, '') // Remove line comments
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
    .replace(/\s+/g, ' ')
    .trim()
    .toUpperCase();

  // Split by semicolons to check each statement individually
  const statements = normalized.split(';').map(s => s.trim()).filter(s => s.length > 0);
  
  // Each statement must be a SELECT query
  for (const statement of statements) {
    if (!statement.startsWith('SELECT')) {
      return { valid: false, error: 'Only SELECT queries are allowed' };
    }
  }

  // Dangerous patterns that should never appear
  const dangerousPatterns = [
    { pattern: /\bDROP\s+/i, description: 'DROP statements' },
    { pattern: /\bDELETE\s+FROM\b/i, description: 'DELETE statements' },
    { pattern: /\bUPDATE\s+/i, description: 'UPDATE statements' },
    { pattern: /\bINSERT\s+INTO\b/i, description: 'INSERT statements' },
    { pattern: /\bTRUNCATE\s+/i, description: 'TRUNCATE statements' },
    { pattern: /\bALTER\s+/i, description: 'ALTER statements' },
    { pattern: /\bCREATE\s+/i, description: 'CREATE statements' },
    { pattern: /\bEXEC\s*\(/i, description: 'EXEC function calls' },
    { pattern: /\bEXECUTE\s+/i, description: 'EXECUTE statements' },
    { pattern: /\bGRANT\s+/i, description: 'GRANT statements' },
    { pattern: /\bREVOKE\s+/i, description: 'REVOKE statements' },
    { pattern: /xp_\w+/i, description: 'Extended stored procedures' },
    { pattern: /sp_\w+/i, description: 'System stored procedures' },
    { pattern: /UNION\s+(?!ALL\s+SELECT)/i, description: 'UNION without SELECT' },
    { pattern: /INTO\s+OUTFILE/i, description: 'File operations' },
    { pattern: /INTO\s+DUMPFILE/i, description: 'File operations' },
    { pattern: /LOAD_FILE\s*\(/i, description: 'File reading functions' },
  ];

  for (const { pattern, description } of dangerousPatterns) {
    if (pattern.test(sql)) {
      return { 
        valid: false, 
        error: `SQL query contains dangerous operation: ${description}` 
      };
    }
  }

  // Additional security checks
  
  // Limit query complexity (prevent DoS via complex queries)
  const subqueryCount = (sql.match(/SELECT/gi) || []).length;
  if (subqueryCount > 5) {
    return { 
      valid: false, 
      error: 'Query too complex (max 5 subqueries allowed)' 
    };
  }

  return { valid: true };
}

/**
 * Sanitizes SQL query for logging (removes potential PII)
 */
function sanitizeSQLForLogging(sql: string): string {
  return sql
    // Replace string literals with placeholder
    .replace(/'[^']*'/g, "'***'")
    .replace(/"[^"]*"/g, '"***"')
    // Replace numbers that might be IDs or sensitive
    .replace(/\b\d{6,}\b/g, '######');
}

export interface QueryExecutionResult {
  data: any[]
  executionTime: number
  rowCount: number
  confidence: number
  suggestions: string[]
  visualization?: VisualizationConfig
  explanation?: string
}

export interface VisualizationConfig {
  type: 'bar' | 'line' | 'pie' | 'table'
  title: string
  xAxis?: string
  yAxis?: string
  data: any[]
}

/**
 * Execute a natural language query against the actual database
 */
export async function executeQuery(
  databaseId: string,
  sql: string,
  naturalQuery: string
): Promise<QueryExecutionResult> {
  const startTime = Date.now()
  
  try {
    // Execute the ACTUAL SQL generated by the LLM
    let result: any[] = []
    
    if (!sql || !sql.trim()) {
      throw new Error('No SQL query provided by the LLM')
    }
    
    // SECURITY: Validate SQL before execution to prevent injection attacks
    const validation = validateSQL(sql);
    if (!validation.valid) {
      console.error('SQL Validation Failed:', validation.error);
      console.error('Rejected SQL:', sanitizeSQLForLogging(sql));
      throw new Error(`Query rejected: ${validation.error}`);
    }
    
    // Log the SQL being executed for debugging (sanitized in production)
    if (process.env.NODE_ENV === 'development') {
      console.log('Executing SQL:', sanitizeSQLForLogging(sql));
    }
    
    // Execute the raw SQL using cached query with intelligent tier selection
    // This provides 5-10x faster response for repeated or similar queries
    const cacheKey = `query:${databaseId}:${sql.substring(0, 100)}`;
    result = await cachedQuery(sql, cacheKey)
    
    console.log(`Query returned ${result.length} rows`)
    
    const executionTime = Date.now() - startTime

    // Calculate confidence score based on result quality
    const confidence = calculateConfidence(result, naturalQuery)

    // Generate actionable suggestions
    const suggestions = generateSuggestions(result, databaseId, naturalQuery)

    // Determine best visualization type
    const visualization = determineVisualization(result, naturalQuery)

    return {
      data: result,
      executionTime,
      rowCount: result.length,
      confidence,
      suggestions,
      visualization
    }
  } catch (error) {
    console.error('Query execution error:', error)
    console.error('Failed SQL:', sanitizeSQLForLogging(sql))
    throw error
  }
}

/**
 * Execute query based on database type
 */
async function executeByDatabase(databaseId: string, naturalQuery: string): Promise<{ data: any[], explanation: string }> {
  const queryLower = naturalQuery.toLowerCase()

  switch (databaseId) {
    case 'sales':
      return await executeSalesQuery(queryLower)
    case 'hr':
      return await executeHRQuery(queryLower)
    case 'inventory':
      return await executeInventoryQuery(queryLower)
    case 'finance':
      return await executeFinanceQuery(queryLower)
    case 'customer_support':
      return await executeSupportQuery(queryLower)
    default:
      throw new Error(`Unsupported database: ${databaseId}`)
  }
}

/**
 * Sales database queries
 */
async function executeSalesQuery(query: string): Promise<{ data: any[], explanation: string }> {
  // Check for customer-related queries
  if (query.includes('customer')) {
    // Top/Best customers by revenue
    if (query.includes('top') || query.includes('best') || query.includes('highest') || 
        query.includes('most') || query.includes('biggest') || query.includes('leading')) {
      const customers = await prisma.salesCustomer.findMany({
        orderBy: { totalSpent: 'desc' },
        take: 10,
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          totalSpent: true,
          city: true,
          state: true,
          dateJoined: true
        }
      })
      const data = customers.map(c => ({
        customer_name: `${c.firstName} ${c.lastName}`,
        email: c.email,
        total_spent: c.totalSpent,
        location: `${c.city}, ${c.state}`,
        member_since: c.dateJoined.toISOString().split('T')[0]
      }))
      
      const totalSpending = customers.reduce((sum, c) => sum + c.totalSpent, 0)
      const avgSpending = customers.length > 0 ? totalSpending / customers.length : 0
      const explanation = `I retrieved a list of the top ${customers.length} customers ranked by their total spending. ` +
        `These customers have spent between $${customers[customers.length - 1]?.totalSpent.toFixed(2)} and $${customers[0]?.totalSpent.toFixed(2)}, ` +
        `with an average spending of $${avgSpending.toFixed(2)} per customer. ` +
        `The list is sorted by spending in descending order, showing highest spenders first.`
      
      return { data, explanation }
    }
    
    // New/Recent customers
    if (query.includes('new') || query.includes('recent') || query.includes('latest') || 
        query.includes('joined')) {
      const customers = await prisma.salesCustomer.findMany({
        orderBy: { dateJoined: 'desc' },
        take: 10,
        select: {
          firstName: true,
          lastName: true,
          email: true,
          totalSpent: true,
          city: true,
          state: true,
          dateJoined: true
        }
      })
      const data = customers.map(c => ({
        customer_name: `${c.firstName} ${c.lastName}`,
        email: c.email,
        total_spent: c.totalSpent,
        location: `${c.city}, ${c.state}`,
        joined_date: c.dateJoined.toISOString().split('T')[0]
      }))
      const explanation = `I found ${customers.length} recent customers, sorted by their join date with the most recent first. ` +
        `These customers joined between ${customers[customers.length - 1]?.dateJoined.toISOString().split('T')[0]} ` +
        `and ${customers[0]?.dateJoined.toISOString().split('T')[0]}.`
      return { data, explanation }
    }
    
    // All customers (general query)
    const customers = await prisma.salesCustomer.findMany({
      orderBy: { totalSpent: 'desc' },
      take: 20,
      select: {
        firstName: true,
        lastName: true,
        email: true,
        totalSpent: true,
        city: true,
        state: true
      }
    })
    const data = customers.map(c => ({
      customer_name: `${c.firstName} ${c.lastName}`,
      email: c.email,
      total_spent: c.totalSpent,
      location: `${c.city}, ${c.state}`
    }))
    const explanation = `I retrieved ${customers.length} customers sorted by their total spending in descending order.`
    return { data, explanation }
  }

  // Check for product-related queries
  if (query.includes('product')) {
    // Low stock products
    if (query.includes('low') || query.includes('stock') || query.includes('inventory') || 
        query.includes('reorder')) {
      const products = await prisma.salesProduct.findMany({
        where: { stockLevel: { lt: 20 } },
        orderBy: { stockLevel: 'asc' },
        take: 10,
        select: {
          name: true,
          category: true,
          stockLevel: true,
          price: true,
          sku: true
        }
      })
      const data = products.map(p => ({
        product_name: p.name,
        category: p.category,
        stock_level: p.stockLevel,
        price: p.price,
        sku: p.sku
      }))
      return wrapResult(data, `Found ${products.length} products with low stock levels (below 20 units), sorted by stock level from lowest to highest.`)
    }
    
    // Top products by price or popular products
    if (query.includes('expensive') || query.includes('highest') || query.includes('top') || 
        query.includes('premium')) {
      const products = await prisma.salesProduct.findMany({
        orderBy: { price: 'desc' },
        take: 10,
        select: {
          name: true,
          category: true,
          stockLevel: true,
          price: true,
          description: true
        }
      })
      const data = products.map(p => ({
        product_name: p.name,
        category: p.category,
        price: p.price,
        stock_level: p.stockLevel,
        description: p.description
      }))
      return wrapResult(data, `Retrieved the top ${products.length} most expensive products, sorted by price from highest to lowest.`)
    }
    
    // All products (general query)
    const products = await prisma.salesProduct.findMany({
      take: 15,
      orderBy: { price: 'desc' },
      select: {
        name: true,
        category: true,
        price: true,
        stockLevel: true
      }
    })
    const data = products.map(p => ({
      product_name: p.name,
      category: p.category,
      price: p.price,
      stock_level: p.stockLevel
    }))
    return wrapResult(data, `Retrieved ${products.length} products sorted by price from highest to lowest.`)
  }

  // Check for order-related queries
  if (query.includes('order') || query.includes('sale')) {
    // Recent orders
    if (query.includes('recent') || query.includes('latest') || query.includes('last') || 
        query.includes('today') || query.includes('this week')) {
      const orders = await prisma.salesOrder.findMany({
        orderBy: { orderDate: 'desc' },
        take: 15,
        include: {
          customer: {
            select: {
              firstName: true,
              lastName: true
            }
          }
        }
      })
      const data = orders.map(o => ({
        order_number: o.orderNumber,
        customer: `${o.customer.firstName} ${o.customer.lastName}`,
        order_date: o.orderDate.toISOString().split('T')[0],
        total_amount: o.totalAmount,
        status: o.status,
        shipping_cost: o.shippingCost
      }))
      return wrapResult(data, `Found ${orders.length} recent orders sorted by date from most recent to oldest.`)
    }
    
    // High value orders
    if (query.includes('high') || query.includes('large') || query.includes('big') || 
        query.includes('top') || query.includes('biggest')) {
      const orders = await prisma.salesOrder.findMany({
        orderBy: { totalAmount: 'desc' },
        take: 10,
        include: {
          customer: {
            select: {
              firstName: true,
              lastName: true
            }
          }
        }
      })
      const data = orders.map(o => ({
        order_number: o.orderNumber,
        customer: `${o.customer.firstName} ${o.customer.lastName}`,
        order_date: o.orderDate.toISOString().split('T')[0],
        total_amount: o.totalAmount,
        status: o.status
      }))
      return wrapResult(data, `Retrieved the top ${orders.length} highest-value orders sorted by total amount from highest to lowest.`)
    }
    
    // All orders
    const orders = await prisma.salesOrder.findMany({
      orderBy: { orderDate: 'desc' },
      take: 20,
      include: {
        customer: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    })
    const data = orders.map(o => ({
      order_number: o.orderNumber,
      customer: `${o.customer.firstName} ${o.customer.lastName}`,
      order_date: o.orderDate.toISOString().split('T')[0],
      total_amount: o.totalAmount,
      status: o.status
    }))
    return wrapResult(data, `Retrieved ${orders.length} orders sorted by date from most recent to oldest.`)
  }

  // Revenue/Sales analysis queries
  if (query.includes('revenue') || query.includes('total') || query.includes('sales')) {
    const orders = await prisma.salesOrder.findMany({
      orderBy: { totalAmount: 'desc' },
      take: 10,
      select: {
        orderNumber: true,
        totalAmount: true,
        orderDate: true,
        status: true
      }
    })
    const data = orders.map(o => ({
      order_number: o.orderNumber,
      amount: o.totalAmount,
      date: o.orderDate.toISOString().split('T')[0],
      status: o.status
    }))
    return wrapResult(data, `Retrieved ${orders.length} orders for revenue analysis, sorted by amount from highest to lowest.`)
  }

  // Default: Get sales summary (top customers)
  const customers = await prisma.salesCustomer.findMany({
    orderBy: { totalSpent: 'desc' },
    take: 10
  })
  const data = customers.map(c => ({
    customer_name: `${c.firstName} ${c.lastName}`,
    total_spent: c.totalSpent,
    location: `${c.city}, ${c.state}`
  }))
  return wrapResult(data, `Retrieved ${customers.length} top customers sorted by total spending from highest to lowest.`)
}

/**
 * HR database queries
 */
async function executeHRQuery(query: string): Promise<{ data: any[], explanation: string }> {
  // Department-related queries
  if (query.includes('department')) {
    const departments = await prisma.hRDepartment.findMany({
      include: {
        employees: {
          select: {
            salary: true,
            status: true,
            position: true
          }
        }
      }
    })

    const data = departments.map(d => {
      const activeEmployees = d.employees.filter(e => e.status === 'ACTIVE')
      const avgSalary = activeEmployees.length > 0
        ? activeEmployees.reduce((sum, e) => sum + e.salary, 0) / activeEmployees.length
        : 0

      return {
        department: d.name,
        employee_count: activeEmployees.length,
        avg_salary: Math.round(avgSalary),
        budget: d.budget || 0,
        description: d.description
      }
    })
    return wrapResult(data, `Retrieved ${departments.length} departments with employee count and average salary information.`)
  }

  // Employee-related queries
  if (query.includes('employee')) {
    // Recent hires
    if (query.includes('new') || query.includes('recent') || query.includes('hire') || 
        query.includes('latest') || query.includes('joined')) {
      const employees = await prisma.hREmployee.findMany({
        where: { status: 'ACTIVE' },
        orderBy: { hireDate: 'desc' },
        take: 15,
        include: {
          department: {
            select: { name: true }
          }
        }
      })

      const data = employees.map(e => ({
        employee_name: `${e.firstName} ${e.lastName}`,
        employee_id: e.employeeId,
        position: e.position,
        department: e.department.name,
        hire_date: e.hireDate.toISOString().split('T')[0],
        salary: e.salary,
        status: e.status
      }))
      return wrapResult(data, `Found ${employees.length} recently hired employees sorted by hire date.`)
    }
    
    // High salary employees
    if (query.includes('high') || query.includes('top') || query.includes('highest') || 
        query.includes('best paid')) {
      const employees = await prisma.hREmployee.findMany({
        where: { status: 'ACTIVE' },
        orderBy: { salary: 'desc' },
        take: 10,
        include: {
          department: {
            select: { name: true }
          }
        }
      })

      const data = employees.map(e => ({
        employee_name: `${e.firstName} ${e.lastName}`,
        position: e.position,
        department: e.department.name,
        salary: e.salary,
        hire_date: e.hireDate.toISOString().split('T')[0]
      }))
      return wrapResult(data, `Retrieved the top ${employees.length} highest-paid employees sorted by salary.`)
    }
    
    // All active employees
    const employees = await prisma.hREmployee.findMany({
      where: { status: 'ACTIVE' },
      orderBy: { hireDate: 'desc' },
      take: 20,
      include: {
        department: {
          select: { name: true }
        }
      }
    })

    const data = employees.map(e => ({
      employee_name: `${e.firstName} ${e.lastName}`,
      employee_id: e.employeeId,
      position: e.position,
      department: e.department.name,
      salary: e.salary,
      hire_date: e.hireDate.toISOString().split('T')[0]
    }))
    return wrapResult(data, `Retrieved ${employees.length} active employees sorted by hire date.`)
  }

  // Salary-related queries
  if (query.includes('salary') || query.includes('compensation') || query.includes('pay')) {
    const employees = await prisma.hREmployee.findMany({
      where: { status: 'ACTIVE' },
      orderBy: { salary: 'desc' },
      take: 15,
      include: {
        department: {
          select: { name: true }
        }
      }
    })

    const data = employees.map(e => ({
      employee_name: `${e.firstName} ${e.lastName}`,
      position: e.position,
      department: e.department.name,
      salary: e.salary,
      hire_date: e.hireDate.toISOString().split('T')[0]
    }))
    return wrapResult(data, `Retrieved ${employees.length} employees sorted by salary from highest to lowest.`)
  }

  // Performance-related queries
  if (query.includes('performance') || query.includes('review') || query.includes('rating')) {
    const reviews = await prisma.hRPerformance.findMany({
      orderBy: { reviewDate: 'desc' },
      take: 15,
      include: {
        employee: {
          select: {
            firstName: true,
            lastName: true,
            position: true,
            department: {
              select: { name: true }
            }
          }
        }
      }
    })

    const data = reviews.map(r => ({
      employee_name: `${r.employee.firstName} ${r.employee.lastName}`,
      position: r.employee.position,
      department: r.employee.department.name,
      review_date: r.reviewDate.toISOString().split('T')[0],
      rating: r.rating,
      reviewer: r.reviewer
    }))
    return wrapResult(data, `Retrieved ${reviews.length} performance reviews sorted by review date.`)
  }

  // Default: Department summary
  const departments = await prisma.hRDepartment.findMany({
    include: {
      employees: {
        where: { status: 'ACTIVE' }
      }
    }
  })

  const data = departments.map(d => ({
    department: d.name,
    employee_count: d.employees.length,
    description: d.description
  }))
  return wrapResult(data, `Retrieved ${departments.length} departments with employee count summaries.`)
}

/**
 * Inventory database queries
 */
async function executeInventoryQuery(query: string): Promise<{ data: any[], explanation: string }> {
  if (query.includes('warehouse') || query.includes('location')) {
    // Warehouse inventory summary
    const warehouses = await prisma.invWarehouse.findMany({
      include: {
        inventory: {
          include: {
            product: {
              select: {
                name: true,
                unitPrice: true
              }
            }
          }
        }
      }
    })

    const data = warehouses.map(w => {
      const totalValue = w.inventory.reduce((sum, inv) => 
        sum + (inv.quantity * inv.product.unitPrice), 0
      )
      const totalItems = w.inventory.reduce((sum, inv) => sum + inv.quantity, 0)

      return {
        warehouse_name: w.name,
        location: `${w.city}, ${w.state}`,
        total_items: totalItems,
        inventory_value: Math.round(totalValue),
        capacity_usage: Math.round((totalItems / w.capacity) * 100)
      }
    })
    return wrapResult(data, `Retrieved ${warehouses.length} warehouse inventory summaries with value and capacity information.`)
  }

  if (query.includes('product') && (query.includes('low') || query.includes('reorder'))) {
    // Low stock products
    const inventory = await prisma.invInventory.findMany({
      include: {
        product: {
          select: {
            name: true,
            minStock: true,
            unitPrice: true
          }
        },
        warehouse: {
          select: {
            name: true
          }
        }
      }
    })

    const lowStock = inventory
      .filter(inv => inv.quantity < inv.product.minStock)
      .map(inv => ({
        product_name: inv.product.name,
        warehouse: inv.warehouse.name,
        current_stock: inv.quantity,
        min_stock: inv.product.minStock,
        deficit: inv.product.minStock - inv.quantity,
        unit_price: inv.product.unitPrice
      }))

    const data = lowStock.slice(0, 10)
    return wrapResult(data, `Found ${data.length} products with stock levels below the minimum reorder threshold.`)
  }

  // Default: Inventory summary
  const products = await prisma.invProduct.findMany({
    take: 10,
    include: {
      inventory: true,
      supplier: {
        select: { name: true }
      }
    }
  })

  const data = products.map(p => ({
    product_name: p.name,
    supplier: p.supplier.name,
    total_quantity: p.inventory.reduce((sum, inv) => sum + inv.quantity, 0),
    unit_price: p.unitPrice
  }))
  return wrapResult(data, `Retrieved ${products.length} products with inventory quantities and supplier information.`)
}

/**
 * Finance database queries
 */
async function executeFinanceQuery(query: string): Promise<{ data: any[], explanation: string }> {
  if (query.includes('account') || query.includes('balance')) {
    // Account balances
    const accounts = await prisma.finAccount.findMany({
      where: { isActive: true },
      orderBy: { balance: 'desc' },
      select: {
        accountName: true,
        accountType: true,
        balance: true,
        currency: true
      }
    })

    const data = accounts.map(a => ({
      account_name: a.accountName,
      account_type: a.accountType,
      balance: a.balance,
      currency: a.currency
    }))
    return wrapResult(data, `Retrieved ${accounts.length} active account balances sorted by balance from highest to lowest.`)
  }

  if (query.includes('transaction') && (query.includes('recent') || query.includes('latest'))) {
    // Recent transactions
    const transactions = await prisma.finTransaction.findMany({
      orderBy: { transactionDate: 'desc' },
      take: 10,
      include: {
        account: {
          select: { accountName: true }
        }
      }
    })

    const data = transactions.map(t => ({
      account: t.account.accountName,
      amount: t.amount,
      type: t.type,
      category: t.category,
      description: t.description,
      date: t.transactionDate.toISOString().split('T')[0]
    }))
    return wrapResult(data, `Retrieved the ${transactions.length} most recent financial transactions sorted by date.`)
  }

  if (query.includes('budget')) {
    // Budget analysis
    const budgets = await prisma.finBudget.findMany({
      orderBy: { budgetYear: 'desc' },
      take: 10
    })

    const data = budgets.map(b => ({
      category: b.category,
      year: b.budgetYear,
      month: b.budgetMonth || 'Annual',
      allocated: b.allocated,
      spent: b.spent,
      remaining: b.remaining,
      usage_percent: Math.round((b.spent / b.allocated) * 100)
    }))
    return wrapResult(data, `Retrieved ${budgets.length} budget entries showing allocated, spent, and remaining amounts.`)
  }

  // Default: Account summary
  const accounts = await prisma.finAccount.findMany({
    where: { isActive: true },
    take: 5
  })

  const data = accounts.map(a => ({
    account_name: a.accountName,
    balance: a.balance
  }))
  return wrapResult(data, `Retrieved ${accounts.length} active account summaries.`)
}

/**
 * Customer Support database queries
 */
async function executeSupportQuery(query: string): Promise<{ data: any[], explanation: string }> {
  if (query.includes('ticket') && (query.includes('open') || query.includes('pending'))) {
    // Open tickets
    const tickets = await prisma.custTicket.findMany({
      where: {
        status: { in: ['OPEN', 'IN_PROGRESS', 'PENDING_CUSTOMER'] }
      },
      orderBy: { createdAt: 'desc' },
      take: 10,
      include: {
        customer: {
          select: {
            firstName: true,
            lastName: true,
            company: true
          }
        }
      }
    })

    const data = tickets.map(t => ({
      ticket_number: t.ticketNumber,
      customer: `${t.customer.firstName} ${t.customer.lastName}`,
      company: t.customer.company,
      subject: t.subject,
      priority: t.priority,
      status: t.status,
      created_at: t.createdAt.toISOString().split('T')[0]
    }))
    return wrapResult(data, `Retrieved ${tickets.length} open/pending support tickets sorted by creation date.`)
  }

  if (query.includes('customer') && (query.includes('tier') || query.includes('premium'))) {
    // Customer tiers
    const customers = await prisma.custCustomer.findMany({
      orderBy: { tier: 'desc' },
      take: 10,
      include: {
        tickets: {
          select: { status: true }
        }
      }
    })

    const data = customers.map(c => ({
      customer_name: `${c.firstName} ${c.lastName}`,
      company: c.company,
      tier: c.tier,
      status: c.status,
      total_tickets: c.tickets.length,
      open_tickets: c.tickets.filter(t => t.status === 'OPEN').length
    }))
    return wrapResult(data, `Retrieved ${customers.length} customers sorted by tier with ticket counts.`)
  }

  // Default: Ticket statistics
  const tickets = await prisma.custTicket.findMany({
    select: {
      status: true,
      priority: true
    }
  })

  const stats = tickets.reduce((acc, t) => {
    const key = `${t.status}_${t.priority}`
    acc[key] = (acc[key] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  const data = Object.entries(stats).map(([key, count]) => {
    const [status, priority] = key.split('_')
    return {
      status,
      priority,
      ticket_count: count
    }
  }).slice(0, 10)
  return wrapResult(data, `Retrieved ticket statistics grouped by status and priority.`)
}

/**
 * Calculate confidence score based on result quality
 * Factors considered:
 * - SQL execution success
 * - Data availability and completeness
 * - Query specificity and intent matching
 * - Result set size appropriateness
 */
function calculateConfidence(result: any[], query: string): number {
  const queryLower = query.toLowerCase()
  
  // No results = low confidence (query may be too restrictive or data doesn't exist)
  if (result.length === 0) {
    return 0.35 // 35% - query executed but found nothing
  }

  // Start with strong base confidence for successful execution with results
  let confidence = 0.80 // 80% base - SQL executed successfully and returned data

  // Factor 1: Result set size appropriateness (±0.10)
  if (result.length >= 1 && result.length <= 3) {
    // Very few results - might be too restrictive or exactly what was asked
    if (queryLower.includes('top 1') || queryLower.includes('single') || queryLower.includes('one')) {
      confidence += 0.10 // Perfect - user wanted specific result
    } else {
      confidence -= 0.05 // Questionable - user may have expected more
    }
  } else if (result.length >= 4 && result.length <= 20) {
    confidence += 0.08 // Good result set size
  } else if (result.length > 100) {
    confidence -= 0.05 // Too many results, might not be specific enough
  }

  // Factor 2: Query intent matching (±0.08)
  const specificKeywords = ['top', 'recent', 'latest', 'best', 'highest', 'lowest', 'most', 'least', 'average', 'sum', 'total', 'count']
  const hasSpecificIntent = specificKeywords.some(keyword => queryLower.includes(keyword))
  
  if (hasSpecificIntent) {
    confidence += 0.08 // User asked for specific analysis - likely accurate
  }
  
  // Factor 3: Data completeness check (±0.07)
  if (result.length > 0) {
    const firstRow = result[0]
    const keys = Object.keys(firstRow)
    const nullCount = keys.filter(key => firstRow[key] === null || firstRow[key] === undefined).length
    const nullRatio = keys.length > 0 ? nullCount / keys.length : 0
    
    if (nullRatio === 0) {
      confidence += 0.07 // All fields populated - high quality data
    } else if (nullRatio > 0.5) {
      confidence -= 0.10 // Too many nulls - data quality concern
    }
  }

  // Factor 4: Numeric data presence for analytical queries (±0.05)
  if (queryLower.includes('how much') || queryLower.includes('how many') || 
      queryLower.includes('total') || queryLower.includes('average') || 
      queryLower.includes('sum') || queryLower.includes('count')) {
    // Check if results contain numeric data
    const hasNumericData = result.some(row => 
      Object.values(row).some(val => typeof val === 'number')
    )
    if (hasNumericData) {
      confidence += 0.05 // Query intent matches result type
    } else {
      confidence -= 0.08 // Missing expected numeric data
    }
  }

  // Factor 5: Date/time queries (±0.03)
  if (queryLower.includes('recent') || queryLower.includes('latest') || 
      queryLower.includes('last') || queryLower.includes('past')) {
    const hasDateData = result.some(row => 
      Object.keys(row).some(key => key.includes('date') || key.includes('time'))
    )
    if (hasDateData) {
      confidence += 0.03 // Time-based query has temporal data
    }
  }

  // Ensure confidence stays within valid range [0.35, 1.0]
  return Math.max(0.35, Math.min(confidence, 1.0))
}

/**
 * Generate actionable suggestions based on results
 */
function generateSuggestions(result: any[], databaseId: string, query: string): string[] {
  const suggestions: string[] = []

  if (result.length === 0) {
    suggestions.push('Try broadening your search criteria')
    suggestions.push('Check if the data exists in this database')
    return suggestions
  }

  // Database-specific suggestions
  switch (databaseId) {
    case 'sales':
      if (query.includes('customer')) {
        suggestions.push('View detailed customer purchase history')
        suggestions.push('Analyze customer lifetime value trends')
      }
      if (query.includes('product')) {
        suggestions.push('Check inventory levels for these products')
        suggestions.push('Review product pricing strategy')
      }
      break

    case 'hr':
      if (query.includes('department')) {
        suggestions.push('Compare department performance metrics')
        suggestions.push('Review headcount allocation across teams')
      }
      if (query.includes('salary')) {
        suggestions.push('Benchmark salaries against industry standards')
        suggestions.push('Analyze compensation trends over time')
      }
      break

    case 'inventory':
      if (query.includes('low') || query.includes('stock')) {
        suggestions.push('Create purchase orders for low stock items')
        suggestions.push('Review minimum stock levels')
      }
      suggestions.push('Optimize warehouse capacity utilization')
      break

    case 'finance':
      if (query.includes('budget')) {
        suggestions.push('Identify categories exceeding budget')
        suggestions.push('Forecast end-of-year budget status')
      }
      suggestions.push('Analyze cash flow patterns')
      break

    case 'customer_support':
      if (query.includes('ticket')) {
        suggestions.push('Prioritize high-priority open tickets')
        suggestions.push('Assign tickets to available agents')
      }
      suggestions.push('Analyze ticket resolution times')
      break
  }

  // Add export suggestion
  suggestions.push('Export this data for further analysis')

  return suggestions.slice(0, 3) // Return top 3 suggestions
}

/**
 * Determine best visualization type for the data
 */
function determineVisualization(result: any[], query: string): VisualizationConfig | undefined {
  if (result.length === 0) return undefined

  const firstRow = result[0]
  const keys = Object.keys(firstRow)

  // Look for common patterns
  const hasAmount = keys.some(k => 
    k.includes('amount') || k.includes('spent') || k.includes('balance') || 
    k.includes('salary') || k.includes('price') || k.includes('value')
  )
  const hasCount = keys.some(k => k.includes('count') || k.includes('quantity'))
  const hasName = keys.some(k => k.includes('name') || k.includes('department') || k.includes('category'))

  // Bar chart for comparisons
  if (hasName && (hasAmount || hasCount)) {
    const nameKey = keys.find(k => k.includes('name') || k.includes('department') || k.includes('category')) || keys[0]
    const valueKey = keys.find(k => k.includes('amount') || k.includes('spent') || k.includes('count') || k.includes('salary')) || keys[1]

    return {
      type: 'bar',
      title: 'Data Comparison',
      xAxis: nameKey,
      yAxis: valueKey,
      data: result.slice(0, 10) // Limit to 10 items for readability
    }
  }

  // Line chart for time series
  if (keys.some(k => k.includes('date') || k.includes('month') || k.includes('year'))) {
    const dateKey = keys.find(k => k.includes('date') || k.includes('month') || k.includes('year'))
    const valueKey = keys.find(k => k.includes('amount') || k.includes('count') || k.includes('value'))

    if (dateKey && valueKey) {
      return {
        type: 'line',
        title: 'Trend Over Time',
        xAxis: dateKey,
        yAxis: valueKey,
        data: result
      }
    }
  }

  // Default to table
  return {
    type: 'table',
    title: 'Query Results',
    data: result
  }
}
